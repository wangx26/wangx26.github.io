<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="校招," />










<meta name="description" content="基础知识 牛客c++ 参考归纳">
<meta property="og:type" content="article">
<meta property="og:title" content="校招基础知识">
<meta property="og:url" content="http://yoursite.com/posts/5b52d467/index.html">
<meta property="og:site_name" content="天风火羽">
<meta property="og:description" content="基础知识 牛客c++ 参考归纳">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/posts/images/virtualmemory.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/page.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/多级页表.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/倒排页表.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/散列表.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/虚拟内存结构.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/大端法小端法.jpg">
<meta property="og:image" content="http://yoursite.com/posts/images/IO模型.jpg">
<meta property="article:published_time" content="2021-08-17T02:55:32.000Z">
<meta property="article:modified_time" content="2022-10-20T02:38:10.097Z">
<meta property="article:author" content="WangXu">
<meta property="article:tag" content="校招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/posts/images/virtualmemory.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/posts/5b52d467/"/>





  <title>校招基础知识 | 天风火羽</title>
  








<meta name="generator" content="Hexo 5.4.2"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天风火羽</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/5b52d467/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天风火羽">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">校招基础知识</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-17T10:55:32+08:00">
                2021-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8B%9B%E8%81%98/" itemprop="url" rel="index">
                    <span itemprop="name">招聘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础知识">基础知识</h1>
<p><a
target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/93/f982cd252694499181bcf1bb83780cad">牛客c++</a>
<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/656779">参考归纳</a></p>
<span id="more"></span>
<h2 id="一操作系统">一、操作系统</h2>
<h3 id="内核态和用户态">1.内核态和用户态</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/user-mode-kernel-mode.html">参考</a></p>
<h4 id="内核态和用户态的区别">内核态和用户态的区别</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266950886">参考</a></p>
<h4 id="什么时候会陷入内核态">什么时候会陷入内核态</h4>
<h4 id="c-访问空指针会不会陷入内核态">C
访问空指针会不会陷入内核态？</h4>
<h3 id="陷阱中断异常信号">2.陷阱、中断、异常、信号</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/07/09/trap-interrupt-exception.html">参考</a></p>
<h4
id="陷阱中断异常信号的产生来源">陷阱、中断、异常、信号的产生来源</h4>
<h4
id="陷阱中断异常信号的处理流程">陷阱、中断、异常、信号的处理流程</h4>
<h4
id="常见的陷阱中断异常信号有哪些">常见的陷阱、中断、异常、信号有哪些？</h4>
<h3 id="进程和线程">3.进程和线程</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/process-thread.html">参考</a></p>
<h4 id="进程与线程的区别">进程与线程的区别</h4>
<h4 id="为什么需要线程">为什么需要线程</h4>
<h4 id="线程的优缺点">线程的优缺点</h4>
<h4
id="同一进程中的线程共享与独占的资源">同一进程中的线程共享与独占的资源</h4>
<h4 id="线程的实现方式">线程的实现方式</h4>
<h4 id="线程池介绍应用场景">线程池介绍、应用场景</h4>
<h3 id="进程的调度">4.进程的调度</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/process-schedule.html">参考</a></p>
<h4 id="进程的状态">进程的状态</h4>
<h4
id="批处理系统交互分时系统实时系统的调度算法">批处理系统、交互（分时）系统、实时系统的调度算法</h4>
<h4 id="僵尸进程孤儿进程守护进程">僵尸进程、孤儿进程、守护进程</h4>
<h3 id="线程和进程的通信方式">5.线程和进程的通信方式</h3>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/02/26/ipc.html">参考</a></p>
<h4
id="信号管道信号量共享内存消息队列套接字">信号、管道、信号量、共享内存、消息队列、套接字</h4>
<h4 id="各种通信方式的原理适用场景">各种通信方式的原理、适用场景</h4>
<h3 id="锁的类型与实现">6.锁的类型与实现</h3>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/locks.html">参考</a></p>
<h4 id="了解哪些类型的锁">了解哪些类型的锁？</h4>
<h4 id="互斥锁的实现方式">互斥锁的实现方式</h4>
<h4 id="自旋锁的实现方式">自旋锁的实现方式</h4>
<h3 id="进程的同步与互斥">7.进程的同步与互斥</h3>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/sync-and-mutex.html">参考</a></p>
<h4 id="临界资源和临界区的概念">临界资源和临界区的概念</h4>
<h4 id="同步和互斥的概念">同步和互斥的概念 ?</h4>
<h4 id="临界区的管理原则">临界区的管理原则</h4>
<h4 id="信号量和-p-v-操作">信号量和 P / V 操作</h4>
<h4 id="原子操作的原理-todo">原子操作的原理 [TODO] ?</h4>
<h4 id="volatile-解决什么问题">volatile 解决什么问题 ?</h4>
<h4 id="一些常见的并发问题">一些常见的并发问题</h4>
<ul>
<li>生产者与消费者问题</li>
<li>读者写者问题</li>
<li>浴室洗澡问题</li>
<li>哲学家就餐问题</li>
</ul>
<h3 id="死锁的预防检测避免解除">8.死锁的预防、检测、避免、解除</h3>
<h4 id="死锁产生的四个必要条件">死锁产生的四个必要条件</h4>
<ul>
<li>互斥条件</li>
<li>占有且等待条件：线程占有已经分配给它们的资源（如锁）并且等待其他的资源（也就是说不会主动释放）</li>
<li>不可抢占条件（也就是说不会被动释放）</li>
<li>环路等待条件：每个进程都在等待下一个进程占有的资源
这四个条件缺少一个就不会有死锁。</li>
</ul>
<h4 id="预防死锁">预防死锁</h4>
<p>预防死锁就是破坏上面四个条件任意一个，但是实现很难：</p>
<ul>
<li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限</li>
<li>破坏占有并等待条件：
实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）
或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）
缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性</li>
<li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能</li>
<li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源，各个进程申请资源的顺序都是从小到大，就不会有环了</li>
</ul>
<h4 id="避免死锁">避免死锁</h4>
<p>允许系统中同时存在四个必要条件，但是每当进程提出资源申请时，系统要分析满足该资源请求后，系统是否会发生死锁，若不会发生则实施分配，否则拒绝分配。银行家算法实现了这个过程。</p>
<h4 id="检测死锁">检测死锁</h4>
<p>画出资源分配图，检测是否存在环路。检测环路前要将资源分配图化简，化简的原理是“一个目前占有运行所需的资源的进程，迟早能够执行完成释放资源”。因此，可以从“进程—资源分配图”中找到一个既不阻塞又非孤立的进程，删除所有与该进程相连的有向边，回收资源，使之成为孤立结点，然后将所回收的资源分配给其它进程。循环此过程，直到无法化简。若仍存在环路，则该系统目前处于死锁状态。</p>
<p>检测到死锁后，需要解除死锁。</p>
<h4 id="解除死锁">解除死锁</h4>
<p>破坏除了“互斥条件”之外的其他三个条件：</p>
<p>回退执行：系统定期对各个进程进行检查，将检查点的有关信息写入文件。死锁时，让某占有必要资源的进程回退到取得资源之前的一个检查点，释放的资源分配给一个死锁进程（破坏“占有且等待”）
抢占资源：剥夺占有进程的资源，分配给另外某些进程，直至死锁环路被打破（破坏“不可抢占”）
杀掉进程：一次终止一个进程，直至消除死锁环路（破坏“循环等待”）</p>
<h3 id="物理内存管理">9.物理内存管理</h3>
<h4 id="内部碎片和外部碎片">内部碎片和外部碎片：</h4>
<p>内部碎片是固定分区法产生的，指被占用分区上未被利用的空间，由于该分区被占用，因此无法被分配使用
外部碎片是动态分区法产生的，指被占用分区之间的小空间，虽然可以被使用，但是由于太小而无法被分配
不同的内存分配技术及其优缺点</p>
<ul>
<li>等长固定分区法：每个分区大小相同，在系统启动时分配好，系统运行期间保持不变；每次给进程分配一整块区域，因此进程的大小必须
≤ 分区的大小
优点：系统需要维护的管理信息非常少，只要维护一个固定行数的表格，记载分区的使用情况；内存分配算法很简单，有足够大空闲分区就分配，否则就拒绝
缺点：不同进程需要的空间不同，内部碎片多，浪费空间；分区总数固定，限制了并发执行的程序数量</li>
<li>不等长固定分区法：每个分区大小不同，在系统启动时分配好，系统运行期间保持不变；分配时，需要根据进程的大小在空闲分区中选择一个大小合适的分区（优缺点同上）</li>
<li>动态分区法：在系统运行中，根据每个进程需要的空间大小确定分区大小；通过空闲分区链表进行组织
优点：并发执行的程序数量不受限制，只取决于是否有大小合适的内存块可以分配
缺点：管理空闲快的复杂度增加；分配算法的时间开销增加，可能需要遍历多次才能找到合适的内存块</li>
<li>页式内存管理：把固定分区面积缩小，一个进程可使用多个分区；进程被分割成若干块，装入内存中的几个分区中，物理上无需相连，逻辑上通过页表关联。这是一种内存的不连续分配方法
优点：不存在任何外部碎片，只在每个进程的最后一个页框中存在内部碎片</li>
<li>段式内存管理：按照逻辑意义将程序分成若干个段，每个段独立载入到内存的不同区间中
优点：分页不考虑每个页中内容的意义，而分段是按照逻辑关系划分
缺点：每个段必须连续、全部加载到内存中</li>
<li>段页式内存管理：把分段和分页两种方式结合，先把程序按照逻辑意义分成段，然后每个段再分成固定大小的页</li>
</ul>
<h4
id="不同的动态分区放置算法及其优缺点">不同的动态分区放置算法及其优缺点</h4>
<ul>
<li>最佳适应算法
检查所有空闲分区，选择和新进程申请内存大小最接近的空闲分区
优点：该算法保留大的空闲区 缺点:
<ul>
<li>检查所有空闲分区需要时间</li>
<li>外部碎片多：会留下许多难以利用的，很小的空闲分区，称为外部碎片</li>
<li>可以采用内存紧凑的方法，将被使用的分区都移动到一起，减少外部碎片。但是移动内存中的代码和数据也需要很多时间</li>
</ul></li>
<li>最差适应算法 每次为进程分配分区时，都选择最大的空闲分区分配
最差适应算法使链表中的结点大小趋于均匀，适用于请求分配的内存大小范围较窄的系统
优点：该算法保留小的空闲区，尽量减少外部碎片的产生
缺点：检查比较所有的空闲区间需要时间；系统中不会存在面积很大的空闲区间，难满足大进程的要求</li>
<li>首次适应法
只要发现能用的分区就分配。这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区
优点：可以剩下大的分区
缺点：外部碎片多，集中在低址部分；并且每次查找都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销</li>
<li>下一个适应法
由于上面的放置算法每次都需要从头检查，有可能浪费很多时间。因此“下一个适应法”就是操作系统记住接下来该检查的空闲分区的位置，给进程分配分区时，系统从记录的分区开始依次向后查找直到碰到能用的分区为止，如果到链表尾还没有找到，就再从头开始
缺点：上面的三个放置算法都是按照分区大小来分配，或是留下大区间（首次适应，最佳适应），或是留下小区间（最差适应）。下一个适应法很难剩下面积很大的区间，会使剩余分区的大小比较平均</li>
</ul>
<h3 id="虚拟内存管理">10.虚拟内存管理</h3>
<h4 id="虚拟内存的思想-实现方式">(1)虚拟内存的思想 / 实现方式</h4>
<ul>
<li>在系统中为每个程序定义一个虚拟地址空间，虚拟地址空间中的地址都是连续的</li>
<li>虚拟地址空间被分割成多个块，每块称为一个页或者<em>页面</em></li>
<li>物理内存被分成和页面大小相同的多个区域，称作<em>页框</em></li>
<li>程序加载时，可将任意一个页面放入内存中的任意一个页框</li>
<li>CPU 的硬件负责将虚拟地址映射到物理内存中的地址（页面 -&gt;
页框）</li>
<li>程序的整个地址空间无需全部载入物理内存，还有部分暂时存储在外存上，需要时再换入内存</li>
<li>如果程序引用到一部分不在物理内存中的虚拟地址时，会发生<em>缺页中断</em>，由操作系统负责将缺失的页面加载入页框中，并重新执行失败的指令</li>
</ul>
<p><img src="../images/virtualmemory.jpg"/></p>
<h4
id="暂时不在内存中的数据存在哪里">(2)暂时不在内存中的数据存在哪里？</h4>
<p>存储在交换分区（swap）中。当内存不足的时候，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，释放内存空间。</p>
<h4 id="虚拟地址的映射">(3)虚拟地址的映射</h4>
<ul>
<li>页表：每个进程有一个页表，描述该进程每个页面对应的页框号，以及该页面是否已经被载入内存（“在/不在”位）。以下是一个进程的页表和地址映射过程的示意图：</li>
</ul>
<p><img src="../images/page.jpg"/></p>
<p>一个完整的页表表项包含以下内容：</p>
<ul>
<li>页框号</li>
<li>存在位：页面是否在内存中：</li>
<li>访问位：页面是否已被访问，影响页面淘汰选择</li>
<li>修改位：页面是否被修改，修改过的页面需要重新写回外存</li>
<li>页面号：在页表中的下标，并不是一项真的内容
进程在运行时，需要将页表放在内存中。但在虚拟地址空间很大的情况下，会被分成很多个页面，那么进程的页表将占据很大的内存空间，甚至无法全部载入内存。有一些针对大内存的页表实现方式：</li>
<li>多级页表：将页表进一步分页，页目录表相当于“页表的页表”，记录每个内层页表存放在哪个页框中；内层页表依然记录进程的每个页面存放在哪个页框中。以下是一个多级页表的示意图：
<img src="../images/多级页表.jpg"/></li>
<li>倒排页表：不再为每个进程记录页面到页框的映射，而是记录每个页框对应的
(进程号, 页面号)
二元组。整个操作系统只需要一个倒排页表，节省了大量空间。但是它必须遍历整个页表才能找到某个表项，无法将页面号当作索引直接找到页框号。
<img src="../images/倒排页表.jpg"/></li>
<li>散列表：为了节省页表空间，同时加速查找过程，可以将当前进程的所有「在内存中」的页面建立一张散列表。用每个页面的虚拟地址来散列，相同散列值的元素会被链接到一起，每个元素包含三项内容：页面号、页框号、指向链表中下一个元素的指针。
<img src="../images/散列表.jpg"/></li>
</ul>
<h4 id="tlb原理">(4)TLB原理</h4>
<p>现代操作系统中，页表的个数是很多的，而每次执行语句时都需要先查找页表，将虚拟地址转换为物理内存地址。这部分切换的时间开销是很大的。因此，解决方案是为计算机设置一个小型的硬件设备
TLB。</p>
<p>转换检测缓冲区（TLB，translation-lookaside buffer），是
MMU（内存管理单元）的一部分。它提供一个缓冲区，记录虚拟页面号到物理页框号的映射，这样可以在
O(1)
的时间里直接将虚拟页面映射到物理页框，不需要访问页表，从而节省时间。</p>
<p>工作流程：如果页面号在 TLB
中，得到页框号，访问内存；否则，从内存中的页表中得到页框号，将其存入
TLB，访问内存。</p>
<p>TLB 基于局部性原理实现：</p>
<ul>
<li>空间局部性：如果程序访问了地址 x，那么很有可能访问 x 附近的地址</li>
<li>时间局部性：如果程序访问了地址 x，很可能立刻又访问 x</li>
</ul>
<h4 id="缺页中断的处理">(5)缺页中断的处理</h4>
<p>应用程序访问未加载到内存中的页面时，会引起缺页中断。操作系统回将缺失的页面加载入页框中，然后重新执行引起异常的指令。</p>
<p>缺页中断更准确地说，应当是“缺页异常（page
fault）”。异常执行当前指令产生的错误情况，中断则是外部硬件产生的事件。</p>
<h4 id="页面淘汰">(6)页面淘汰</h4>
<p>当内存空间已被占满而又要调入新的页面时，必须将已在内存中的某个页面淘汰掉。如果被淘汰的页面曾被修改过，还要将此页写回到外存，再换进新的页面。这一过程称为页面淘汰。</p>
<p>如果某个页面频繁的被“调入-淘汰-调入-淘汰”，这种现象称为抖动。抖动导致系统将大部分时间花在了页面的置换上，因此在淘汰时，要选择今后不会或者最近不会用到的内容，以减少抖动。</p>
<h4 id="不同的淘汰算法及其适用场景">(7)不同的淘汰算法及其适用场景</h4>
<p>根据具体的应用场景，选择合适的淘汰算法。除了操作系统的页面置换，redis
中也经常用到各种内存淘汰算法，往往需要结合具体业务场景来选择。</p>
<p>以下是几种常见的淘汰算法：</p>
<ol type="1">
<li>最佳置换算法/最优策略（OPT）：选择以后再也不会用到的页面淘汰；如果都会用到，就选择那些再次使用的时间距离现在最远的页面淘汰。这是一种理想情况下的页面置换算法，实际上不可能实现。可以作为评测其他淘汰策略的标准。</li>
<li>先进先出法（FIFO）：直接换出最早装入的页面。
<ol type="1">
<li>优点：简单</li>
<li>缺点：性能不是很好，因为它淘汰的可能是常用的页面</li>
<li>适用场景：数据只用一次，将来不太可能使用；redis对数据时效性有要求（越旧的缓存越先被淘汰）</li>
</ol></li>
<li>第二次机会置换法（SCR：Second Chance Replacement）：对 FIFO
算法的改进，每个页面访问 2
次后再淘汰。具体实现上，设置页面访问位，每次检查队首的页面访问位：如果该位为
0，淘汰该页；如果该位为 1，将该位设为 0，将其移到队尾，看成新装入的页。
<ol type="1">
<li>优点：一定程度上，避免把经常使用的页面置换出去</li>
</ol></li>
<li>时钟置换法（Clock）：对第二次机会置换法的改进。第二次机会置换法需要在链表中移动页面，而时钟置换法将页面保存在环形链表中，只需要后移队头指针，就相当于是把原来的队头放到队尾了。
<ol type="1">
<li>优点：避免了移动链表节点的开销</li>
</ol></li>
<li>最近最少使用法（LRU：Least Recently
Used）：优先淘汰最久未被访问的页面。根据局部性原理，一个进程在一段时间内要访问的指令和数据都集中在一起。如果一个页面很久没有被访问，那么将来被访问的可能性也比较小。
<ol type="1">
<li>优点：实验证明 LRU 的性能较好，能够降低置换频率</li>
<li>缺点：存在缓存污染问题，即由于偶发性或周期性的冷数据批量查询，热点数据被挤出去，导致缓存命中率下降</li>
<li>适用场景：访问分布未知的情况；redis要求热点数据有效；redis应用对缓存的访问符合二八定律
/ 幂律分布</li>
</ol></li>
<li>LRU-K：LRU-K 算法的核心思想是将“最近使用过 1
次”的判断标准扩展为“最近使用过 K 次”，LRU 可以认为是
LRU-1。能够降低“缓存污染”的问题。</li>
<li>最近最不经常使用法（LFU：Least Frequently
Used）：优先淘汰最近访问频率最少的数据。
<ol type="1">
<li>优点：能够避免缓存污染问题对 LRU 的命中影响</li>
<li>缺点：存在访问模式问题，即如果访问内容发生较大变化，LFU
需要用更长的时间来适应，导致缓存命中率下降；维护相关数据结构的开销大</li>
<li>适用场景：[redis] 数据的访问模式固定</li>
</ol></li>
<li>随机淘汰法（Random）：实现简单，不需要保留有关访问历史记录的任何信息
<ol type="1">
<li>适用场景：[redis] 如果应用对于缓存 key
的访问概率相等，则可以使用这个算法</li>
</ol></li>
</ol>
<p>操作系统常用的是 LRU
算法；一般数据的访问模式是随时间变化的，所以大多数的缓存也都是使用 LRU
算法或其变种。还有一些其他算法如 MRU、SLRU</p>
<h3 id="虚拟地址空间的组成部分">11.虚拟地址空间的组成部分</h3>
<h4 id="虚拟地址空间的组成部分-1">(1)虚拟地址空间的组成部分</h4>
<p>整体上，操作系统将每个进程的虚拟地址空间划分成两个部分：内核空间和用户空间。内核空间存放的是内核代码和数据，用户空间存放的是用户程序的代码和数据。在
32 位操作系统中，一般将最高的 1G 字节作为内核空间，而将较低的 3G
字节作为用户空间。</p>
<p>进程运行在内核空间时，处于内核态，此时可以执行任何特权指令。每个进程的内核空间都是相同的，用户代码无法访问内核空间。</p>
<p>虚拟地址空间的完整组成 <img src="../images/虚拟内存结构.jpg"/></p>
<p>从上往下依次是：</p>
<ul>
<li>内核虚拟内存：所有进程共享内核的代码和全局数据结构，独享与进程相关的数据结构，Linux
会将内核虚拟内存的共享区域映射到被所有进程共享的物理页面上</li>
<li>用户栈：从高地址向低地址增长</li>
<li>共享库：动态链接阶段</li>
<li>运行时堆：从低地址向高地址增长</li>
<li>程序代码和数据：从可执行文件中加载（代码段、数据段、BSS 段）</li>
</ul>
<h4 id="栈">(2) 栈</h4>
<p>用户栈其实就是函数调用栈，作用主要是：</p>
<ul>
<li>保存函数的局部变量</li>
<li>保存某些寄存器的值</li>
<li>向被调用函数传递参数</li>
<li>返回函数的返回值</li>
<li>保存函数的返回地址
每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值，这块栈内存为该函数的栈帧（stack
frame）。栈的增长和收缩由编译器插入的代码自动完成，随着函数的调用而分配，随函数的返回而自动释放。程序员无需关心，这一点与堆不同。</li>
</ul>
<h4 id="堆">(3) 堆</h4>
<p>栈内存的分配需要实现确定其大小，而堆内存允许程序在运行时动态申请某个大小的内存空间。申请的内存在函数退出后依然保留，需要手动释放。C
语言中的 malloc / free 就是从堆中分配 /
释放内存，操作系统通过一个记录空闲内存地址的链表来管理堆内存。</p>
<p>如果反复向操作系统申请堆内存而不释放，会导致内存泄漏。在 C / C++
中，必须由程序员手动释放堆内存。而 Java / Golang
中有垃圾回收器，会定期主动回收内存。但是即使有垃圾回收器，也有内存泄漏的风险，比如长期持有某个大对象的引用。</p>
<h4 id="栈和堆的区别">(4) 栈和堆的区别</h4>
<ul>
<li>增长方向：栈向低地址方向增长，堆向高地址方向增长</li>
<li>申请回收：栈自动分配和回收，堆需要手动申请和释放</li>
<li>生命周期：栈的数据仅存在于函数运行过程中，堆的数据只要不释放就一直存在</li>
<li>连续分配：栈是连续分配的，堆是不连续的，容易产生内存碎片</li>
<li>空间大小：栈的大小是有限的（如默认 8M，Linux 上通过 ulimit -s
查看），而堆的空间较大，受限于系统中有效的虚拟内存</li>
</ul>
<h3 id="进程的内存管理">12.进程的内存管理</h3>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/malloc.html">参考</a></p>
<h4 id="mallocfree-的原理">malloc、free 的原理</h4>
<h3 id="大端法小端法">13.大端法、小端法</h3>
<h4 id="什么是大端法小端法">什么是大端法、小端法</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144718837">大端法和小端法</a>
计算机最小的可寻址的内存单位是字节。按有效字节在内存地址中从小到大的存储顺序，可以分为大端法和小端法：大端法从高位到低位存储，小端法从低位到高位存储。比如某个
int 型整数的值为 0x01234567，存储在 0x100~0x103
的内存地址上。大端法和小端法的字节顺序如下所示：
<img src="../images/大端法小端法.jpg"/></p>
<h4
id="如何判断一台机器是大端法还是小端法">如何判断一台机器是大端法还是小端法</h4>
<p>按内存地址顺序从低到高输出一个变量的全部字节，可以借助 char*
类型的指针来完成</p>
<h4
id="面试真题判断以下程序在-32-位机器上的输出">面试真题：判断以下程序在
32 位机器上的输出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">  <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%02x\n&quot;</span>, *p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%02x\n&quot;</span>, *(p + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%02x\n&quot;</span>, *(p + <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小端法输出 34 12 00，大端法输出 00 00 12</p>
<h3 id="缓冲区溢出问题">14.缓冲区溢出问题</h3>
<h4 id="什么是缓存区溢出">什么是缓存区溢出？</h4>
<p>C
语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C
对于数组引用不进行任何边界检查，因此对越界的数组元素的写操作会破坏存储在栈中的状态信息，这种现象称为缓冲区溢出。</p>
<h4 id="缓冲区溢出攻击的方式">缓冲区溢出攻击的方式</h4>
<p>缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。</p>
<h4 id="缓冲区溢出攻击的防范方法">缓冲区溢出攻击的防范方法</h4>
<ol type="1">
<li>随机化</li>
</ol>
<p>使用缓冲区溢出进行攻击，需要知道攻击代码的地址。因此常见的防范方法有：</p>
<ul>
<li>栈随机化：程序开始时在栈上分配一段随机大小的空间</li>
<li>地址空间布局随机化（Address-Space Layout
Randomization，ASLR）：每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域
但是攻击者依然可以使用蛮力克服随机化，这种方式称为“空操作雪橇（nop
sled）”，即在实际的攻击代码前插入很长的一段 nop
指令序列，执行这条指令只会移动到下一条指令。因此只要攻击者能够猜中这段序列的某个地址，程序就会最终经过这段序列，到达攻击代码。</li>
</ul>
<p>因此栈随机化和 ASLR
只能增加攻击一个系统的难度，但不能完全保证安全。</p>
<ol start="2" type="1">
<li>栈保护</li>
</ol>
<p>在发生缓冲区溢出、造成任何有害结果之前，尝试检测到它。常见的栈破坏检测方法是栈保护机制：在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。</p>
<ol start="3" type="1">
<li>限制可执行代码区域</li>
</ol>
<p>内存页的访问形式有三种：可读、可写、可执行。只有编译器产生的那部分代码所处的内存才是可执行的，其他页应当限制为只允许读和写。以前
x86
将读和执行视为一个标志位，可读就可执行，为了限制某些页可读但不可执行，往往会带来严重的性能损失。现在新的处理器在硬件上引入新的位，将读和执行分开，由硬件来检查页是否可执行，效率上没有损失。</p>
<h3 id="io-模型">15.I/O 模型</h3>
<h4 id="种-io-模型">5 种 I/O 模型:</h4>
<p>阻塞 I/O、非阻塞 I/O、信号驱动式 I/O、I/O 多路复用、异步
I/O（AIO）</p>
<h4 id="同步-io-和异步-io">同步 I/O 和异步 I/O:</h4>
<p>I/O
同步和异步的区别在于：将数据从内核复制到用户空间时，用户进程是否会阻塞（需要用户进程来完成）</p>
<h4 id="阻塞-io-和非阻塞-io">阻塞 I/O 和非阻塞 I/O:</h4>
<p>I/O
阻塞和非阻塞的区别在于：进程发起系统调用后，是会被挂起直到收到数据后在返回、还是立即返回成功或错误
<img src="../images/IO模型.jpg"/></p>
<h4 id="io-多路复用select-poll-epoll">I/O 多路复用：select / poll /
epoll:</h4>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/02/27/select-poll-epoll.html">参考</a></p>
<ul>
<li>阻塞 I/O</li>
<li>非阻塞 I/O----I/O
多路复用(系统调用为同步阻塞)：检查文件描述符从用户态移至内核态</li>
<li>为什么 I/O 多路复用内部需要使用非阻塞
I/O：一个系统调用，检查多个文件描述符</li>
<li>select</li>
<li>文件描述符（file descriptor）:是一个非负整数，从 0
开始。每个进程维护一个文件描述符表，表示该进程打开文件的记录表，而文件描述符实际上就是这张表的索引</li>
<li>socket 与 fd 的关系：socket 是进程间通信规则的高层抽象，而 fd
提供的是底层的具体实现。socket()返回的就是这个 socket 对应的文件描述符
fd。通过 socket 通信，实际上就是通过文件描述符 fd 读写文件。</li>
<li>fd_set 文件描述符集合：二进制每一位来表示一个文件描述符</li>
<li>select 的缺点：性能开销大；同时能够监听的文件描述符数量太少</li>
<li>poll：poll 和 select 几乎没有区别。poll
采用数组的方式存储文件描述符，没有最大存储数量的限制。从性能开销上看，poll
和 select 的差别不大。</li>
<li>epoll：在内核中维护文件描述符集合，创建实例。连接数较多并且有很多的不活跃连接时，epoll
的效率比其它两者高很多
<ul>
<li>使用红黑树存储文件描述符集合</li>
<li>使用队列存储就绪的文件描述符</li>
<li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li>
</ul></li>
<li>水平触发、边缘触发</li>
<li>为什么边缘触发必须使用非阻塞 I/O？</li>
<li>Redis 的线程模型：单线程的工作模型，使用 I/O
多路复用来处理客户端的多个连接
<ul>
<li>多线程技术是为了充分利用 CPU
的计算资源，适用于下层存储慢速的场景。</li>
<li>redis 是纯内存操作，不涉及任何 I/O
操作，因此多线程频繁的上下文切换反而是一种负优化</li>
<li>redis 在最新的几个版本中也引入了多线程：异步处理删除操作；应对网络
I/O 的场景</li>
</ul></li>
</ul>
<h3 id="协程">16.协程</h3>
<h4 id="什么是协程">什么是协程？</h4>
<p>协程是一个用户态的线程，用户在堆上模拟出协程的栈空间。当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态，就可以实现上下文切换。没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。</p>
<h4 id="协程的实现原理">协程的实现原理：</h4>
<p>最基本的协程实现原理可以参考这篇文章，分析了一个简单的 C++ coroutine
的源码实现。协程的实现重点在于：</p>
<ul>
<li>在堆上模拟栈，从而实现一个用户态的线程</li>
<li>调度器，负责协程的调度与上下文切换 Golang 的 goroutine
也是一个有栈协程。Golang 实现了自己的调度器 (GMP 模型)，使用队列管理协程
(运行队列、等待队列)；Golang
封装了系统调用，将阻塞的系统调用改为非阻塞的系统调用，从而在系统调用前将陷入“阻塞”的协程“切换”到等待队列，并让出计算资源。从
1.2 版本开始，goroutine 变为抢占式调度。</li>
</ul>
<h4 id="协程切换哪些数据">协程切换哪些数据？</h4>
<p>类似于线程的切换，协程切换时需要保存：</p>
<ul>
<li>寄存器，包括 PC (指令位置) 和 CPU 寄存器 (参数、上下文…)</li>
<li>栈指针</li>
<li>返回值</li>
</ul>
<h4 id="协程的栈空间大小">协程的栈空间大小：</h4>
<p>线程栈是固定大小的，可以使用 ulimit -a 查看。默认情况也是 8M（8192
字节），而协程占用的栈空间大小由 runtime 按需进行分配
(初始时很小，随后动态扩展)</p>
<h3 id="写时复制-copy-on-write">17.写时复制 Copy-on-write</h3>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/copy-on-write.html">参考</a>
为什么需要 COW？ 实现原理 优缺点 实际应用</p>
<h2 id="二计算机网络">二、计算机网络</h2>
<h3 id="协议栈">1.协议栈</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/protocol-stack.html">参考</a></p>
<h4 id="osi-参考模型">OSI 参考模型</h4>
<p>7层</p>
<p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<h4 id="tcpip-参考模型">TCP/IP 参考模型</h4>
<p>从上到下分为 4 层，对应于 OSI 中的 5 层：</p>
<ul>
<li>应用层：对应于 OSI 参考模型的应用层</li>
<li>传输层：对应于 OSI 参考模型的传输层</li>
<li>网络层（或网际互联层）：对应于 OSI 参考模型的网络层</li>
<li>网络接入层：对应于 OSI 参考模型的物理层和数据链路层</li>
</ul>
<h4 id="tcpip-参考模型各层常见协议">TCP/IP 参考模型各层常见协议</h4>
<h4 id="比较-tcpip-参考模型与-osi-参考模型">比较 TCP/IP 参考模型与 OSI
参考模型</h4>
<h4 id="集线器网桥交换机路由器">集线器、网桥、交换机、路由器</h4>
<h4 id="比特帧数据包数据段报文">比特、帧、数据包、数据段、报文</h4>
<h4 id="mslttlrtt-是什么">MSL、TTL、RTT 是什么？</h4>
<h3 id="tcp协议">2.TCP协议</h3>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP
的那些事儿（上）</a> <a
target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP
的那些事儿（下）</a></p>
<h3 id="tcp-的流量控制和拥塞控制">3.TCP 的流量控制和拥塞控制</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/tcp-flow-control-congestion.html">参考</a></p>
<h4 id="流量控制-flow-control">流量控制 Flow Control</h4>
<p>零窗口、Nagle 算法、发送端如何调节发送速率</p>
<h4 id="拥塞控制">拥塞控制</h4>
<p>拥塞窗口 cwnd（congestion window）</p>
<p>慢启动、拥塞避免、超时重传</p>
<h3 id="tcp-的三次握手和四次挥手">4.TCP 的三次握手和四次挥手</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/tcp-shake-wave.html">参考</a></p>
<h4 id="tcp-标志位">TCP 标志位</h4>
<ul>
<li>SYN（synchronous）： 发送/同步标志，用来建立连接，和 ACK
标志位搭配使用</li>
<li>ACK（acknowledgement）：确认标志，表示确认收到请求</li>
<li>PSH（push）
：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理</li>
<li>FIN（finish）：结束标志，表示关闭一个 TCP 连接</li>
<li>RST（reset）：重置复位标志，用于复位对应的 TCP 连接</li>
<li>URG（urgent）：紧急标志，用于保证 TCP
连接不被中断，并且督促中间层设备尽快处理</li>
</ul>
<h4 id="tcp-序列号确认号">TCP 序列号、确认号</h4>
<h4 id="三次握手">三次握手</h4>
<h4
id="为什么需要三次握手而不是两次或四次">为什么需要三次握手，而不是两次或四次？</h4>
<h4 id="什么是-syn-攻击如何防范">什么是 SYN 攻击？如何防范？</h4>
<h4 id="四次挥手">四次挥手</h4>
<h4 id="为什么需要四次挥手">为什么需要四次挥手</h4>
<h4
id="为什么第四次挥手客户端的-time-wait-状态必须等待-2msl-的时间才能返回到-closed-状态">为什么第四次挥手，客户端的
TIME-WAIT 状态必须等待 2MSL 的时间才能返回到 CLOSED 状态？</h4>
<h4
id="如果已经建立了连接但是客户端出现故障了怎么办">如果已经建立了连接，但是客户端出现故障了怎么办？</h4>
<h4
id="time_wait-是主动断开连接的一方还是被动断开连接的一方会进入的状态">TIME_WAIT
是主动断开连接的一方、还是被动断开连接的一方会进入的状态？</h4>
<h3 id="tcp-的粘包问题">5.TCP 的粘包问题</h3>
<h4 id="什么是粘包粘包的产生原因">什么是粘包？粘包的产生原因</h4>
<p>TCP
是基于字节流的，数据块是没有边界、没有结构的字节流，因此可能产生粘包：</p>
<p>发送方为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。
接收方不能及时读取数据，导致缓冲区中的多个包粘连。</p>
<h4 id="如何解决粘包问题">如何解决粘包问题？</h4>
<ul>
<li>发送方关闭 Nagle 算法</li>
<li>应用层定义消息边界，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）
<ul>
<li>基于长度的实现有两种方式，一种是使用固定长度；另一种方式是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，HTTP
协议的消息边界就是基于长度实现的</li>
<li>HTTP
协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP
使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length
了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界
除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用 TCP
协议发送 JSON 数据，接收方可以根据接收到的数据是否能够被解析成合法的
JSON 判断消息是否终结。</li>
</ul></li>
</ul>
<p>但值得注意的是，粘包并不是 TCP 协议本身的“问题”，而是一个“现象”。TCP
本身面向字节流的特性，导致会有所谓的“粘包”问题，需要应用层进行拆分。所以也有一种说法是“TCP
粘包是一个伪命题”。</p>
<p>为什么 UDP 协议没有粘包问题？UDP 是面向报文的，应用层交给 UDP
多长的报文，UDP
就照样发送，既不合并，也不拆分，而是保留这些报文的边界。</p>
<h3 id="tcp-协议其他">6.TCP 协议（其他）</h3>
<h4 id="tcp-为什么是面向连接的">TCP 为什么是面向连接的：</h4>
<ul>
<li>发送之前需要先建立连接（三次握手）</li>
<li>使用排序和确认机制（分组之间并不是独立的；记录了分组之间的状态信息）</li>
<li>具有流量控制与拥塞控制</li>
<li>发送完毕后要释放连接（四次挥手）</li>
</ul>
<h4 id="tcp-如何保证传输的可靠性">TCP 如何保证传输的可靠性？</h4>
<ul>
<li>序列号：解决乱序问题</li>
<li>确认号 / 超时重传机制：解决丢包问题</li>
</ul>
<h3 id="tcpudp-对比">7.TCP、UDP 对比</h3>
<ul>
<li>TCP：面向连接的、可靠的、基于字节流的传输层通信协议</li>
<li>UDP：无连接的、不可靠的、基于报文的传输层通信协议</li>
</ul>
<h4 id="面向字节流面向报文的含义">面向字节流、面向报文的含义</h4>
<ul>
<li>面向字节流：TCP
将要发送的数据视为无结构的字节流，如果发送的数据太长，就拆分发送，如果发送的数据太短，则积累较多的字节后再发送</li>
<li>面向报文：UDP 一次发送一个报文，不管多大，都以报文为发送单位</li>
</ul>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 52%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">TCP</th>
<th style="text-align: left;">UDP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">连接性</td>
<td style="text-align: left;">面向连接</td>
<td style="text-align: left;">无连接</td>
</tr>
<tr class="even">
<td style="text-align: left;">可靠性</td>
<td style="text-align: left;">可靠</td>
<td style="text-align: left;">不可靠</td>
</tr>
<tr class="odd">
<td style="text-align: left;">传输方式</td>
<td style="text-align: left;">面向字节流</td>
<td style="text-align: left;">面向报文（保留报文的边界）</td>
</tr>
<tr class="even">
<td style="text-align: left;">传输速度</td>
<td style="text-align: left;">慢</td>
<td style="text-align: left;">快</td>
</tr>
<tr class="odd">
<td style="text-align: left;">双工性</td>
<td style="text-align: left;">全双工</td>
<td style="text-align: left;">一对一、一对多、多对一、多对多</td>
</tr>
<tr class="even">
<td style="text-align: left;">流量控制 / 拥塞控制</td>
<td style="text-align: left;">有</td>
<td style="text-align: left;">无</td>
</tr>
<tr class="odd">
<td style="text-align: left;">应用场景</td>
<td
style="text-align: left;">对效率要求相对低，但是对准确性要求高的场景；或是要求有连接的场景。如文件传输、发送邮件等</td>
<td
style="text-align: left;">对效率要求相对高，对准确性要求相对低的场景。如即时通信、直播等</td>
</tr>
<tr class="even">
<td style="text-align: left;">应用层协议</td>
<td
style="text-align: left;">SMTP（电子邮件）、TELNET（远程登录控制）、HTTP、FTP</td>
<td
style="text-align: left;">DNS、TFTP（文件传输）、DHCP（动态主机配置）...</td>
</tr>
</tbody>
</table>
<h3 id="http-原理">8.HTTP 原理</h3>
<p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/http.html">参考</a></p>
<h4 id="http-请求方法">HTTP 请求方法</h4>
<p>GET、HEAD、POST、PUT、PATCH、DELETE、OPTIONS，以及不常用的
CONNECT、TRACE</p>
<ul>
<li>幂等的：一个 HTTP
方法是幂等的，指的是同样的请求执行一次与执行多次的效果是一样的。
<ul>
<li>常见的幂等方法：GET，HEAD，PUT，DELETE，OPTIONS</li>
<li>常见的非幂等方法：POST</li>
</ul></li>
<li>安全的：一个 HTTP
方法是安全的，指的是这是一个对服务器只读操作的方法，不会修改服务器数据。
<ul>
<li>常见的安全方法：GET，HEAD，OPTIONS</li>
<li>常见的不安全方法：PUT，DELETE，POST</li>
</ul></li>
</ul>
<h4 id="get-和-post-的区别">GET 和 POST 的区别</h4>
<h4 id="http-状态码">HTTP 状态码</h4>
<ul>
<li>信息响应（100–199）</li>
<li>成功响应（200–299）</li>
<li>重定向（300–399）</li>
<li>客户端错误（400–499）</li>
<li>服务器错误 （500–599）</li>
</ul>
<h4 id="cookie-与-session-的区别">Cookie 与 Session 的区别</h4>
<p>二者都是用来跟踪浏览器用户身份的会话方式</p>
<h4 id="http-的长连接与短连接">HTTP 的长连接与短连接</h4>
<h4 id="http1.0http1.1http2.0-的变化">HTTP/1.0、HTTP/1.1、HTTP/2.0
的变化</h4>
<h4 id="http-报文格式">HTTP 报文格式</h4>
<ul>
<li>请求报文：请求行、请求头、和消息主体</li>
<li>响应报文：状态行、响应头、消息主体</li>
</ul>
<h4 id="http-报文语法规则">HTTP 报文语法规则</h4>
<h4 id="http-分块传输编码">HTTP 分块传输编码</h4>
<h3 id="https-原理">9.HTTPS 原理</h3>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903573952675847">HTTPS
四次握手过程</a></p>
<ul>
<li>HTTPS 四次握手过程</li>
<li>访问的网站是如何自动切换到 HTTPS 的</li>
<li>什么是中间人攻击？如何预防？</li>
</ul>
<h3 id="http-的缓存机制">10.HTTP 的缓存机制</h3>
<p><a
target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/588770">HTTP缓存</a></p>
<p>强制缓存、协商缓存的原理，两者对比
判断缓存失效的依据（Expires、Last-Modified、ETag 等） 与缓存相关的 HTTP
状态码 与缓存相关的 HTTP 消息头 用户行为与缓存是否刷新的关系
缓存策略的选择思路</p>
<h3 id="dns-原理">11.DNS 原理</h3>
<p><a
target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/06/dns.html">DNS原理</a></p>
<p>整体流程：浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS
缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。</p>
<p>DNS 查询共有两类：递归查询和迭代查询。递归查询是指，当 A 向 B
查询某个域名的 IP 地址时，如果 B 不知道被查询的域名的 IP 地址，那么 B
会替 A 向更上层的服务器发起查询，将查询结果返回 A。迭代查询是指，当 A 向
B 查询某个域名的 IP 地址时，如果 B 不知道被查询的域名的 IP 地址，B
会告诉 A 下一步应该向哪个服务器查询，由 A 自己去查。</p>
<p>一般来说，主机（也就是我们的电脑）向本地域名服务器的查询是递归查询，而本地域名服务器向根域名服务器的查询是迭代查询。</p>
<h3 id="ip-原理">12.IP 原理</h3>
<ul>
<li>IP 号分类规则 <a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54593244">IP号</a></li>
<li>如何划分子网</li>
<li>IP 分组转发规则</li>
<li>什么是 NAT 协议</li>
<li>什么是 ARP 协议</li>
<li>集线器、网桥、交换机、路由器位于哪一层</li>
<li>为什么局域网的 IP 普遍是 192.168 开头</li>
<li>IPv6 的基本概念 / 为什么引入 IPv6</li>
</ul>
<h3 id="从输入一个-url-到页面加载完成的过程">13.从输入一个 URL
到页面加载完成的过程</h3>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2020/02/26/what-happens-when-you-type-in-a-url.html">URL全过程</a></p>
<h3 id="两台主机间的通信过程">14.两台主机间的通信过程</h3>
<p>ARP协议<a
target="_blank" rel="noopener" href="https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md#%E4%BB%80%E4%B9%88%E6%98%AFarp%E5%8D%8F%E8%AE%AE-address-resolution-protocol">ARP协议</a></p>
<h3 id="socket-通信">15.Socket 通信</h3>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">socket</a></p>
<ul>
<li>Socket 通信流程图（服务端、客户端）</li>
<li>创建服务端：socket() / bind() / listen() / accept() / read()/write()
/ close()</li>
<li>创建客户端：socket() / connect() / read()/write() / close()</li>
<li>上述各个系统调用的作用</li>
<li>TCP 和 UDP 可以同时监听同一个端口吗？
<ul>
<li>TCP 和 UDP 可以同时监听同一个端口，操作系统根据五元组
{传输协议，源IP，目的IP，源端口，目的端口} 判断数据的接收者</li>
</ul></li>
</ul>
<h2 id="三数据库">三、数据库</h2>
<h3 id="数据库基础">1.数据库基础</h3>
<h4 id="数据库三个范式的定义">数据库三个范式的定义</h4>
<p>Normal
Form，8个范式：1NF、2NF、3NF、BCNF、4NF、5NF、DKNF、6NF，常用前3个</p>
<ul>
<li>1NF：列的原子性，即列不能够再分成其他几列</li>
<li>2NF：
<ul>
<li>满足1NF</li>
<li>表必须有一个主键</li>
<li>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分</li>
</ul></li>
<li>3NF：
<ul>
<li>满足1NF，2NF</li>
<li>任何非主属性不依赖于其它非主属性，在2NF基础上消除传递依赖</li>
</ul></li>
</ul>
<h4 id="内连接外连接的含义">内连接、外连接的含义</h4>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39220472/article/details/81193617">内外连接</a>
<a
target="_blank" rel="noopener" href="https://blog.csdn.net/plg17/article/details/78758593">示意图</a></p>
<ul>
<li>left join
（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。</li>
<li>right join
（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。</li>
<li>inner join
（等值连接或者叫内连接）：只返回两个表中连接字段相等的行。</li>
<li>full join
（全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。</li>
</ul>
<h4 id="主键联合主键">主键、联合主键</h4>
<ul>
<li>复合主键：表的主键含有一个以上的字段组成</li>
<li>联合主键：多个主键联合形成一个主键组合，与复合主键同意。“联合主键”还是单一主键，只不过往往用在关联表里，一个关联表里会涉及到多个其他表的主键组合形成一条数据，你既可以为它们设置一个“复合主键”、也可以再新加一个自增列设为“联合主键”。</li>
</ul>
<h4 id="游标的原理">游标的原理</h4>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/lavasoft/13470">游标原理</a></p>
<ul>
<li>SQL查询结果一般都是多条纪录的结果集，而高级语言一次只能处理一条纪录，用游标机制，将多条纪录一次一条读取出来处理</li>
<li>一个游标可以存放多个记录，然后通过游标可以单独处理每一个游标中的记录</li>
<li>就本质而言，游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制</li>
</ul>
<h3 id="数据库的存储引擎">2.数据库的存储引擎</h3>
<h4 id="mysql-支持哪些存储引擎">MySQL 支持哪些存储引擎</h4>
<p>现代数据库大体可以分为三层。</p>
<ul>
<li>最上层用于连接、线程处理等</li>
<li>中间层提供数据库的核心功能，包括 SQL 解析、分析、优化、视图等</li>
<li>底层就是数据库的存储引擎，负责数据的存储与提取
存储引擎为数据库屏蔽了底层存储的细节</li>
</ul>
<h4 id="不同存储引擎的区别适用场景">不同存储引擎的区别、适用场景</h4>
<p>只有 InnoDB 引擎支持事务</p>
<ul>
<li>InnoDB：是最广泛使用的存储引擎。支持事务，满足 ACID
约束。支持行级锁，崩溃恢复和多版本并发控制（MVCC）。是唯一支持外键引用完整性约束的存储引擎。
<ul>
<li>存储方式：聚集索引，B+树</li>
<li>支持事务、行锁、外键、MVCC 等特性</li>
<li>并发能力较好，适用于更新密集的场景。这是因为在更新数据时，InnoDB
使用的是行锁，粒度小，竞争情况少，从而增加增加了并发处理（插入数据时使用的是表锁）</li>
<li>读写效率较差。主要原因在于索引查询后还需要根据主键进行二次查找</li>
<li>占用空间大</li>
</ul></li>
<li>MyISAM：是一个很快的存储引擎。不支持事务。只支持表级锁。常用在 Web
和数据仓库中。
<ul>
<li>顺序存储的。索引的 B+ 树叶节点存放数据记录的地址</li>
<li>占用空间小</li>
<li>处理速度快，适用于选择（select）密集的场景。这是因为可以通过索引节点直接定位到数据，不需要二次查找</li>
<li>支持全文索引（InnoDB 也支持）</li>
<li>不支持事务</li>
<li>只支持表级锁（为了并发插入）</li>
</ul></li>
<li>Memory：将数据表创建在内存中，是最快的存储引擎。不支持事务，支持表级锁。Memory
存储引擎很适合于创建临时表或者快速查询的场景。当数据库重启时，内存中的数据会丢失</li>
</ul>
<h3 id="数据库的索引">3.数据库的索引</h3>
<h4 id="索引类型">索引类型</h4>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037683781">索引类型</a>
按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。
按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。
按字段特性分类可分为：主键索引、普通索引、前缀索引。
按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。</p>
<h4 id="索引的实现原理">索引的实现原理</h4>
<h4 id="索引的优缺点">索引的优缺点</h4>
<ul>
<li>索引的优点：
<ul>
<li>建立索引的列可以保证行的唯一性，生成唯一的rowId</li>
<li>建立索引可以有效缩短数据的检索时间</li>
<li>建立索引可以加快表与表之间的连接</li>
<li>为用来排序或者是分组的字段添加索引可以加快分组和排序顺序</li>
</ul></li>
<li>索引的缺点：
<ul>
<li>创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大</li>
<li>创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）</li>
<li>会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长</li>
</ul></li>
</ul>
<h4 id="如何设置索引">如何设置索引？</h4>
<h4 id="数据库为什么用-b-树做索引如果是内存数据库用什么">数据库为什么用
B+ 树做索引？如果是内存数据库用什么？</h4>
<p>用 B+ 树是为了减少 I/O 次数：</p>
<ul>
<li>不可能把索引全部加载到内存中，只能逐一加载每个索引节点</li>
<li>B+ 树的单个节点中包含的值个数越多，那么节点总数就会越少，I/O
次数也越少</li>
<li>B+ 树高度一般为 2-4 层，查找记录时最多只需要 2-4 次 I/O</li>
<li>相反，二叉搜索树的高度高，所以需要的 I/O 次数更多</li>
<li>如果是内存数据库，不涉及磁盘 I/O，可以直接用二叉搜索树。</li>
</ul>
<h4 id="联合索引与最左匹配原则">联合索引与最左匹配原则</h4>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/14007766.html">最左匹配</a>
最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</p>
<p>我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。</p>
<p>在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引</p>
<h4
id="数据库查询-offset-的流程如果-offset-非常大会有什么问题分页查询">数据库查询
offset 的流程？如果 offset 非常大会有什么问题？分页查询</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343547947"></a> limit y 表示:
读取 y 条记录 limit x, y 表示: 跳过 x 条记录，读取 y 条记录 limit y
offset x 表示: 跳过 x 条记录，读取 y 条记录</p>
<ul>
<li>为了实现分页，每次收到分页请求时，数据库都需要进行低效的全表扫描。要获取所有记录放入内存，然后获取LIMIT指定结果。</li>
<li>优化：基于游标分页</li>
<li>再优化：覆盖索引优化</li>
</ul>
<h3 id="数据库的事务">4.数据库的事务</h3>
<h4 id="事务的特性">事务的特性</h4>
<p>ACID:原子性，持久性，隔离性，一致性 并发控制的基本单位</p>
<h4 id="事务可能存在的并发问题">事务可能存在的并发问题</h4>
<p>级联回滚</p>
<h4
id="事务的隔离级别各个隔离级别可能发送的问题">事务的隔离级别，各个隔离级别可能发送的问题</h4>
<ul>
<li>RAED UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（Dirty
Read）；</li>
<li>READ
COMMITED：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable
Read）；</li>
<li>REPEATABLE
READ：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom
Read）；</li>
<li>SERIALIZABLE：InnoDB
隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li>
</ul>
<p>以上的所有的事务隔离级别都不允许脏写入（Dirty
Write），也就是当前事务更新了另一个事务已经更新但是还未提交的数据</p>
<h3 id="数据库的并发控制">5.数据库的并发控制</h3>
<p><a
target="_blank" rel="noopener" href="https://draveness.me/database-concurrency-control/">数据库并发</a></p>
<h4 id="乐观锁悲观锁mvcc-的原理">乐观锁、悲观锁、MVCC 的原理</h4>
<ul>
<li>悲观锁：
<ul>
<li>读写锁：互斥、共享</li>
<li>两阶段锁协议：在增长阶段，一个事务可以获得锁但是不能释放锁；而在缩减阶段事务只可以释放锁，并不能获得新的锁</li>
<li>死锁：
<ul>
<li>预防死锁</li>
<li>死锁检测和恢复</li>
</ul></li>
</ul></li>
<li>乐观锁：不是锁，并发控制思想
<ul>
<li>基于时间戳的协议</li>
<li>基于验证的协议</li>
</ul></li>
<li>MVCC：每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了
MVCC 需要解决的主要问题</li>
</ul>
<h3
id="数据库分库分表主从读写分离">6.数据库分库、分表、主从、读写分离</h3>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7874e1b8d531">分库分表</a>
MySQL单库数据量在5000万以内性能比较好,超过阈值后性能会随着数据量的增大而变弱。MySQL单表的数据量是500w-1000w之间性能比较好,超过1000w性能也会下降。
mysql的分库分表是在数据量大后的一个常用数据库优化方法</p>
<ul>
<li>水平拆分：把A表拆分为多个表，A_001,A_002,A_003,A_004,A_005这样平均每个表只有200w的数据</li>
<li>垂直拆分：把A表中的author和content字段抽离出来到独立的一个表中C，A中字段变为id，c_id。。等多个字段，C表中的字段就只有id，author和content</li>
</ul>
<h4
id="垂直分库垂直分表垂直拆分的优缺点">垂直分库、垂直分表、垂直拆分的优缺点</h4>
<ul>
<li>垂直切分的优点：
<ul>
<li>解决业务系统层面的耦合，业务清晰</li>
<li>与微服务的治理类似，也能对不同业务的数据进行分级管理，维护，监控，扩展等。</li>
<li>高并发场景下，垂直切分一定程度的提升IO，数据库连接数，单机硬件资源的瓶颈。</li>
</ul></li>
<li>垂直切分的缺点
<ul>
<li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度。</li>
<li>分布式事处理复杂</li>
<li>依然存在单表数据量过大的问题。</li>
</ul></li>
</ul>
<h4 id="库内分表分库分表分表策略">库内分表、分库分表、分表策略</h4>
<h4 id="垂直分库的关键问题跨节点-join事务">垂直分库的关键问题：跨节点
Join、事务</h4>
<h4
id="分库分表的关键问题事务查询跨分片-join跨节点聚合唯一-id分页排序">分库分表的关键问题：事务、查询、跨分片
Join、跨节点聚合、唯一 ID、分页排序</h4>
<h4 id="主从复制的原理binary-log">主从复制的原理（binary log）</h4>
<h4 id="读写分离">读写分离</h4>
<h3 id="数据库的优化方法">7.数据库的优化方法</h3>
<p>SQL 语句优化 索引优化 数据库部署优化（主从分离、读写分离） 数据库拆分
系统配置的优化、硬件的优化</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag"># 校招</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/6ce63535/" rel="next" title="hexo 报错 Cannot find module 'hexo' from ...">
                <i class="fa fa-chevron-left"></i> hexo 报错 Cannot find module 'hexo' from ...
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/b1f94453/" rel="prev" title="云GPU平台">
                云GPU平台 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.</span> <span class="nav-text">一、操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.内核态和用户态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">内核态和用户态的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">什么时候会陷入内核态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E8%AE%BF%E9%97%AE%E7%A9%BA%E6%8C%87%E9%92%88%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">C
访问空指针会不会陷入内核态？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.陷阱、中断、异常、信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9D%A5%E6%BA%90"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">陷阱、中断、异常、信号的产生来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">陷阱、中断、异常、信号的处理流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">常见的陷阱、中断、异常、信号有哪些？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">为什么需要线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">线程的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%8B%AC%E5%8D%A0%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">同一进程中的线程共享与独占的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">线程的实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">线程池介绍、应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">1.1.4.</span> <span class="nav-text">4.进程的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">批处理系统、交互（分时）系统、实时系统的调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">僵尸进程、孤儿进程、守护进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">5.线程和进程的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%AE%A1%E9%81%93%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">信号、管道、信号量、共享内存、消息队列、套接字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">各种通信方式的原理、适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.6.</span> <span class="nav-text">6.锁的类型与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%81"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">了解哪些类型的锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">互斥锁的实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">自旋锁的实现方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">1.1.7.</span> <span class="nav-text">7.进程的同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">临界资源和临界区的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">同步和互斥的概念 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86%E5%8E%9F%E5%88%99"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">临界区的管理原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C-p-v-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">信号量和 P &#x2F; V 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E7%90%86-todo"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">原子操作的原理 [TODO] ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.7.6.</span> <span class="nav-text">volatile 解决什么问题 ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.7.7.</span> <span class="nav-text">一些常见的并发问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E6%A3%80%E6%B5%8B%E9%81%BF%E5%85%8D%E8%A7%A3%E9%99%A4"><span class="nav-number">1.1.8.</span> <span class="nav-text">8.死锁的预防、检测、避免、解除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">死锁产生的四个必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">预防死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">检测死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="nav-number">1.1.8.5.</span> <span class="nav-text">解除死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.9.</span> <span class="nav-text">9.物理内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">内部碎片和外部碎片：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">不同的动态分区放置算法及其优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.10.</span> <span class="nav-text">10.虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%80%9D%E6%83%B3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">(1)虚拟内存的思想 &#x2F; 实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%82%E6%97%B6%E4%B8%8D%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">(2)暂时不在内存中的数据存在哪里？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.10.3.</span> <span class="nav-text">(3)虚拟地址的映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tlb%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.10.4.</span> <span class="nav-text">(4)TLB原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.1.10.5.</span> <span class="nav-text">(5)缺页中断的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E6%B7%98%E6%B1%B0"><span class="nav-number">1.1.10.6.</span> <span class="nav-text">(6)页面淘汰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.10.7.</span> <span class="nav-text">(7)不同的淘汰算法及其适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">1.1.11.</span> <span class="nav-text">11.虚拟地址空间的组成部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86-1"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">(1)虚拟地址空间的组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">(2) 栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.1.11.3.</span> <span class="nav-text">(3) 堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.11.4.</span> <span class="nav-text">(4) 栈和堆的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.12.</span> <span class="nav-text">12.进程的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mallocfree-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">malloc、free 的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E7%AB%AF%E6%B3%95%E5%B0%8F%E7%AB%AF%E6%B3%95"><span class="nav-number">1.1.13.</span> <span class="nav-text">13.大端法、小端法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E6%B3%95%E5%B0%8F%E7%AB%AF%E6%B3%95"><span class="nav-number">1.1.13.1.</span> <span class="nav-text">什么是大端法、小端法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%98%AF%E5%A4%A7%E7%AB%AF%E6%B3%95%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%E6%B3%95"><span class="nav-number">1.1.13.2.</span> <span class="nav-text">如何判断一台机器是大端法还是小端法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E5%88%A4%E6%96%AD%E4%BB%A5%E4%B8%8B%E7%A8%8B%E5%BA%8F%E5%9C%A8-32-%E4%BD%8D%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">1.1.13.3.</span> <span class="nav-text">面试真题：判断以下程序在
32 位机器上的输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.14.</span> <span class="nav-text">14.缓冲区溢出问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-number">1.1.14.1.</span> <span class="nav-text">什么是缓存区溢出？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.14.2.</span> <span class="nav-text">缓冲区溢出攻击的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.14.3.</span> <span class="nav-text">缓冲区溢出攻击的防范方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.15.</span> <span class="nav-text">15.I&#x2F;O 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%8D-io-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">5 种 I&#x2F;O 模型:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-io-%E5%92%8C%E5%BC%82%E6%AD%A5-io"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">同步 I&#x2F;O 和异步 I&#x2F;O:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E-io-%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-io"><span class="nav-number">1.1.15.3.</span> <span class="nav-text">阻塞 I&#x2F;O 和非阻塞 I&#x2F;O:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8select-poll-epoll"><span class="nav-number">1.1.15.4.</span> <span class="nav-text">I&#x2F;O 多路复用：select &#x2F; poll &#x2F;
epoll:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.1.16.</span> <span class="nav-text">16.协程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.1.16.1.</span> <span class="nav-text">什么是协程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.16.2.</span> <span class="nav-text">协程的实现原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.16.3.</span> <span class="nav-text">协程切换哪些数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.1.16.4.</span> <span class="nav-text">协程的栈空间大小：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6-copy-on-write"><span class="nav-number">1.1.17.</span> <span class="nav-text">17.写时复制 Copy-on-write</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.</span> <span class="nav-text">二、计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.协议栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#osi-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">OSI 参考模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcpip-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">TCP&#x2F;IP 参考模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcpip-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%90%84%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">TCP&#x2F;IP 参考模型各层常见协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-tcpip-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8E-osi-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">比较 TCP&#x2F;IP 参考模型与 OSI
参考模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8%E7%BD%91%E6%A1%A5%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">集线器、网桥、交换机、路由器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E7%89%B9%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%8C%85%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8A%A5%E6%96%87"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">比特、帧、数据包、数据段、报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mslttlrtt-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">MSL、TTL、RTT 是什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.TCP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.TCP 的流量控制和拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-flow-control"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">流量控制 Flow Control</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.TCP 的三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">TCP 标志位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E5%BA%8F%E5%88%97%E5%8F%B7%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">TCP 序列号、确认号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E5%9B%9B%E6%AC%A1"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">为什么需要三次握手，而不是两次或四次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-syn-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">什么是 SYN 攻击？如何防范？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">为什么需要四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-time-wait-%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2msl-%E7%9A%84%E6%97%B6%E9%97%B4%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0-closed-%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">为什么第四次挥手，客户端的
TIME-WAIT 状态必须等待 2MSL 的时间才能返回到 CLOSED 状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">如果已经建立了连接，但是客户端出现故障了怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time_wait-%E6%98%AF%E4%B8%BB%E5%8A%A8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%80%E6%96%B9%E8%BF%98%E6%98%AF%E8%A2%AB%E5%8A%A8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%80%E6%96%B9%E4%BC%9A%E8%BF%9B%E5%85%A5%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.4.10.</span> <span class="nav-text">TIME_WAIT
是主动断开连接的一方、还是被动断开连接的一方会进入的状态？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.5.</span> <span class="nav-text">5.TCP 的粘包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%E7%B2%98%E5%8C%85%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">什么是粘包？粘包的产生原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">如何解决粘包问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-%E5%8D%8F%E8%AE%AE%E5%85%B6%E4%BB%96"><span class="nav-number">1.2.6.</span> <span class="nav-text">6.TCP 协议（其他）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">TCP 为什么是面向连接的：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">TCP 如何保证传输的可靠性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpudp-%E5%AF%B9%E6%AF%94"><span class="nav-number">1.2.7.</span> <span class="nav-text">7.TCP、UDP 对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">面向字节流、面向报文的含义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.8.</span> <span class="nav-text">8.HTTP 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">HTTP 请求方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">GET 和 POST 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">HTTP 状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cookie-%E4%B8%8E-session-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.8.4.</span> <span class="nav-text">Cookie 与 Session 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.8.5.</span> <span class="nav-text">HTTP 的长连接与短连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http1.0http1.1http2.0-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.2.8.6.</span> <span class="nav-text">HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0
的变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.8.7.</span> <span class="nav-text">HTTP 报文格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E6%8A%A5%E6%96%87%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">1.2.8.8.</span> <span class="nav-text">HTTP 报文语法规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81"><span class="nav-number">1.2.8.9.</span> <span class="nav-text">HTTP 分块传输编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#https-%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.9.</span> <span class="nav-text">9.HTTPS 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.10.</span> <span class="nav-text">10.HTTP 的缓存机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns-%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.11.</span> <span class="nav-text">11.DNS 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ip-%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.12.</span> <span class="nav-text">12.IP 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.13.</span> <span class="nav-text">13.从输入一个 URL
到页面加载完成的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.14.</span> <span class="nav-text">14.两台主机间的通信过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E9%80%9A%E4%BF%A1"><span class="nav-number">1.2.15.</span> <span class="nav-text">15.Socket 通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.</span> <span class="nav-text">三、数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.数据库基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E4%B8%AA%E8%8C%83%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">数据库三个范式的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">内连接、外连接的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">主键、联合主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">游标的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.数据库的存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">MySQL 支持哪些存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">不同存储引擎的区别、适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.数据库的索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">索引的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">索引的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">如何设置索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-b-%E6%A0%91%E5%81%9A%E7%B4%A2%E5%BC%95%E5%A6%82%E6%9E%9C%E6%98%AF%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">数据库为什么用
B+ 树做索引？如果是内存数据库用什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">联合索引与最左匹配原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2-offset-%E7%9A%84%E6%B5%81%E7%A8%8B%E5%A6%82%E6%9E%9C-offset-%E9%9D%9E%E5%B8%B8%E5%A4%A7%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">数据库查询
offset 的流程？如果 offset 非常大会有什么问题？分页查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.数据库的事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">事务的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">事务可能存在的并发问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%90%84%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%AF%E8%83%BD%E5%8F%91%E9%80%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">事务的隔离级别，各个隔离级别可能发送的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.数据库的并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81mvcc-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">乐观锁、悲观锁、MVCC 的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">1.3.6.</span> <span class="nav-text">6.数据库分库、分表、主从、读写分离</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">垂直分库、垂直分表、垂直拆分的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%93%E5%86%85%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%88%86%E8%A1%A8%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">库内分表、分库分表、分表策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E8%B7%A8%E8%8A%82%E7%82%B9-join%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">垂直分库的关键问题：跨节点
Join、事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E4%BA%8B%E5%8A%A1%E6%9F%A5%E8%AF%A2%E8%B7%A8%E5%88%86%E7%89%87-join%E8%B7%A8%E8%8A%82%E7%82%B9%E8%81%9A%E5%90%88%E5%94%AF%E4%B8%80-id%E5%88%86%E9%A1%B5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">分库分表的关键问题：事务、查询、跨分片
Join、跨节点聚合、唯一 ID、分页排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86binary-log"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">主从复制的原理（binary log）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">读写分离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.7.</span> <span class="nav-text">7.数据库的优化方法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WangXu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
